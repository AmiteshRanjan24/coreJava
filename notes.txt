> Java was developed in 1991 by James Gosling and his team at Sun Microsystems. Initially it was called Oak, then Green and 
  finally Java inspired by Java coffee. In 2010, Sun Microsystems was acquired by Oracle. 

> The smallest building block in java program is a function. Functions are specific block of code 
  that performs a specific task.

> Every Java program must have at least one class.
    > If the class is public, the filename must match the class name. Let's say the className is HelloWorld then file 
    name must be HelloWorld.java

    > In the Java programming language, every application must contain a main method as it is the entry point of the 
    application. 


> public static void main(String[] args)
    public: Allows JVM to access the method from anywhere.
    static: Method can run without creating an object.
    void: It doesn’t return any value.
    String[] args: Accepts command-line arguments.

> System.out.println("Hello, World");
    System: Built-in class from java.lang package.
    out: Static member (PrintStream object) of System.
    println(): Method that prints to console and moves to the next line.


===================== *** Different Editions of Java *** =================================================


> We have four different Editions of java for building different applications : 
  1. Standard Edition (SE)
  2. Enterprise Edition (EE): used for building very large scale fault tolerant distributed applications.
                              It is build on top of Standard Edition. 

  3. Micro Edition (ME): It is a subset of Java Standard Edition designed for mobile devices so it has 
                         libraries specific to mobile devices. 

  4. Java Card: it is used in smart cards. 


=========================== *** Implementation a Java Program *** ========================================================


> Steps to Implement a Java Program: 
    > Java is a platform-independent language that follows a two-step execution process:
        Compilation (source code -> bytecode)
        Execution (bytecode -> machine code via JVM)
    
    1. Compilation in Java
        Java source code (.java files) is compiled by the Java Compiler (javac) into Bytecode, stored in .class files. 
        This bytecode is platform-independent and ready to run on any system with a JVM.

    2. Execution via JVM
        The .class files are executed by the Java Virtual Machine (JVM), which includes the following stages:
        2.1 Class Loader
            Loads the main class and other dependencies into memory.

        2.2 Bytecode Verifier
            Checks that the loaded bytecode is safe to execute. It ensures:
            Variables are initialized
            Method signatures are correct
            Private access rules aren’t violated
            No stack overflows
        
        2.3 Just-In-Time (JIT) Compiler
            Converts bytecode into native machine code at runtime for faster execution.


> WORA — Write Once, Run Anywhere

> Why is Java considered secure?
    Because of:
    No pointer arithmetic
    Bytecode verification
    Security Manager
    Sandbox execution model

> Java LTS versions are: 8, 11, 17, 21

================================ *** JVM (Java Virtual Machine) *** =========================================================


> The Java Virtual Machine (JVM) is a core component of the Java Runtime Environment (JRE) that allows Java programs to run 
  on any platform without modification.
  JVM acts as an interpreter between Java bytecode and the underlying hardware, providing Java’s famous Write Once, Run 
  Anywhere (WORA) capability.

    - Java source (.java) -> compiled by javac -> bytecode (.class)
    - JVM loads the bytecode, verifies it, links it, and then executes it
    - Execution may involve interpreting bytecode or using Just-In-Time (JIT) compilation to convert “hot” code into native 
    - machine code for performance
    - Garbage collection runs in the background to reclaim memory from unused objects


> JVM (Java Virtual Machine) is responsible for:
    Loading bytecode
    Verifying bytecode
    Executing bytecode 

> 



================================= *** Taking I/O *** =================================================================


> We can take input from a user by two methods: 
  1. Scanner
  2. BufferedReader + InputStreamReader
  3. Console
  4. DataInputStream (old but faster, now it is outdated)
  5. Using Command Line Arguments 

    -------------------------------------------------
    | Feature | Scanner            | BufferedReader |
    | ------- | ------------------ | -------------- |
    | Speed   | Slower             | Faster         |
    | Parsing | Built-in (nextInt) | Manual parsing |
    | Ease    | Beginner-friendly  | More control   |
    -------------------------------------------------
    ---------------------------------------------------------------
    | Method            | Speed  | Ease   | Use Case              |
    | ----------------- | ------ | ------ | --------------------- |
    | Scanner           | Slow   | Easy   | Small input, learning |
    | BufferedReader    | Fast   | Medium | CP, large input       |
    | Console           | Medium | Easy   | Secure input          |
    | DataInputStream   | Fast   | Hard   | Legacy code           |
    | Command Line Args | Fast   | Easy   | Config                |
    ---------------------------------------------------------------

> Scanner sc = new Scanner(System.in);    // here we write "System.in" because we are taking input from terminal

    sc.nextLine() //  it will take whole string as input
    sc.next() // it will take only first string as input, if the user type "Ramesh Bhatt" only Ramesh is taken as input. 
    sc.nextInt()
    sc.nextFloat()
    sc.nextDouble()


> We can use both Scanner and BufferedReader together but it is not recommended due to input buffer conflicts.



============================ *** Primitive and Non-Primitive *** ===========================================


> There are two types in Java: 

  1. Primitive: for storing simple values. Some of the primitive types are: 
                byte, short, int, long, float, double. 
            
            > The range of byte is [-128, 127]. 
            > Char in java is of 2 bytes unlike C++ in which it is of 1 byte. 
            > Bool is of 1 byte.   

  2. Reference (Non-primitive): for storing complex values. example : string,arrays, Hashmaps




======================================= *** Parse Methods in Java *** =================================================


> Java parse methods convert strings into primitive data types and are provided by wrapper classes like Integer, 
  Double, and Boolean. They throw NumberFormatException for invalid inputs, except Boolean.parseBoolean which returns false.

> Parse methods convert a String → primitive data type. Most parse methods are static methods of wrapper classes.

> 


========================================= *** IMP *** ================================================================


> By default value of:
  String is null 
  int is 0
  float is 0.0 

> In Java:
    == or != → compares reference
    .equals() → compares value/content

> Example 1: 
    String a = new String("java");
    String b = new String("java");

    System.out.println(a == b);        // false
    System.out.println(a.equals(b));   // true

    Here, a and b point to different objects in memory


> Example 2: 
    String x = "java";
    String y = "java";

    System.out.println(x == y);        // true
    System.out.println(x.equals(y));   // true

    String literals are stored in the String Constant Pool
    Both references point to the same object


> Since Java 7, numeric literals can include underscores (_) purely for readability.
    int a = 100000;
    int b = 100_000;
    int c = 1_00_000;
    They all represent the same integer → 100000.


============================================ *** For each Loop *** =======================================================


> For Each Loop: 
    for (int x : arr) {
        System.out.println(x);
    }

> Some of the shortcomings of For Each Loop are: 
    1. It is always forwarding. It means we cannot iterate over a array backwards. 
    2. We do not have access to index. 



===================================== *** Java Collections Framework *** ====================================================


> Java Collections Framework is a unified architecture that provides interfaces, classes, and algorithms to store, 
  manipulate, and retrieve groups of objects efficiently. Introduced in Java 1.2

> CORE components are: 
    1. Interfaces: Iterable, Collection, List, Queue, Set 
    2. Implementation(Classes): ArrayList, PriorityQueue, HashSet, LinkedList
    3. Algorithms: Sorting, Searching


> The Iterable interface represents an object that is iterable meaning we can iterate or loop over it without knowing anything
  about its implementation detail. 

> 



======================================= *** Packages *** ==================================================================


> For reference: https://www.geeksforgeeks.org/java/packages-in-java/


> A package in Java is a mechanism to group related classes, interfaces, and sub-packages into a single unit. Packages help 
  organize large applications, avoid naming conflicts, provide access protection, and make code modular and maintainable.

> Avoiding name conflicts (two classes with the same name can exist in different packages)
  Providing access control using public, protected, and default access
  Reusability: packaged code can be imported and used anywhere
  Encouraging modular programming

> There are two types of packages: 
  1. Built-in packages: 
        > Built-in Packages comprise a large number of classes that are part of the Java API. Some of the commonly used 
          built-in packages are: java.lang, java.io, java.util, etc.

  2. User defined packages: 
        > packages that are defined by the user.


> Packages in Java are like folders that organize your code files, provide namespaces, and help manage access and distribution.


======================================= *** OOPS *** =======================================================================


> Object-Oriented Programming (OOP) is a programming paradigm that organizes code into objects that contain data (attributes) 
  and behavior (methods).
  The goal is to model real-world entities and make code modular, reusable, and maintainable.

> The fundamental unit of OOP is the object, which represents real-world entities with data (attributes) and behavior 
  (methods).

> class is a logical construct. 
> Object is an instance of a class. So here by instance we mean: Object is the physical reality. This is the thing which 
  exists in the memory or occupy space in memory. Example: Baby is a instance of human class.

> Properties of Objects: 
  1. State of the object
  2. Identity of the object
  3. Behavior of the object

> All objects in Java are allocated on the heap. Stack stores only references and primitives.

> For objects in java the by default value stored in memory is null. 

> In Java we cannot access the memory address of an object, as we do in C++. 

> Static Variables are Stored in the Method Area (a part of JVM memory model). 

> To check type of object we can use: 
  1. instanceof
        if (obj instanceof Student) {
            // true if obj is a Student or subclass
        }
  
  2. getClass() 
        String s = "Hello";
        System.out.println(s.getClass().getName()); // java.lang.String
 


====================================== *** Inheritance *** =========================================================


> Inheritance – Allowing one class to acquire properties and behaviors of another class.
  Example: 
         A Car class inheriting from a Vehicle class.


> Even like all the parent classes inherits from the Object class but it is done by java internally so no need to 
  explicitly write super() inside its constructor. 


> We cannot have child reference variable and parent object. 
  Example:
         Suppose we have parent class Box and child class Cube, so we cannot have something like this-
         Cube c1 = new Box(); // this is wrong, because parent class Box will not be able to call child class constructor

         Box b1 = new Cube(); // this can be done. 

    > Also we have access to only reference type variable. i.e. we can access Properties of only Box even if we create object
      of type Cube. 


:: *** IMP *** :: 

    If the reference is of base class and object is of child class then we can access only base class members.
      This is correct for:
      ✔ fields (variables)
      ✔ methods that are not overridden
      ✔ compile-time checks

    > For overridden methods, JVM looks at the object type (Child), not the reference type (Parent).
      This is done at runtime which is also called dynamic dispatch. 


> static method can be inherited but cannot be overridden because it belongs to class and not to objects. 
  i.e. we can access static methods via subclass also but we cannot override it in subclass.


> TYPES OF INHERITANCE:  

  single inheritance:     one subclass inherits one superclass; 
  multilevel inheritance: continues in a chain; 
  hierarchical:           multiple subclasses inherit from a single superclass; 
  multiple inheritance:   a class inherits from multiple classes; 
  hybrid:                 is a combination of two or more types.

> C++ supports all types, Java does not support multiple inheritance using classes but achieves it through interfaces.


> Java does not support multiple inheritance using classes to avoid ambiguity caused by the Diamond Problem and to keep 
  the language simpler and more maintainable. Instead, Java provides interfaces that allow multiple inheritance of type 
  without causing ambiguity.


> Java does not support hybrid inheritance using classes because it avoids multiple inheritance of classes. However, Java can 
  achieve hybrid inheritance using interfaces. So hybrid inheritance is indirectly supported through interfaces.


> C++ allows multiple inheritance because it gives developers lower-level control and expects them to explicitly resolve 
  ambiguities, while Java prioritizes simplicity and avoids such complex scenarios.


> Java doesn’t support multiple inheritance using classes, but it allows multiple inheritance through interfaces since 
  interfaces only define behavior and don’t create ambiguity in the state. By combining single class inheritance with 
  multiple interface implementation, Java can also achieve hybrid inheritance. 


> If multiple interfaces declare the same abstract method, there’s no conflict because the class must implement it. 
  If multiple interfaces provide default implementations of the same method, Java reports an ambiguity error and forces 
  the class to override the method and choose which one to use. This is how Java safely supports multiple inheritance 
  using interfaces.



======================================== *** Encapsulation *** =======================================================


> Encapsulation – Binding data and methods that operate on that data together, and restricting direct access to some 
  components.
  Example: Private variables in a class with public getters and setters.

> Encapsulation addresses implementation-level concerns, while abstraction addresses design-level concerns.

> Encapsulation focuses on hiding implementation details and protecting data at the code level, whereas abstraction focuses 
  on hiding complexity and defining clear behavior at the design level.

> Data hiding is achieved via encapsulation. 


======================================== *** Abstraction *** =============================================================


> Abstraction – Hiding implementation details and showing only the essential features.
  Example: A std::sort() function in C++ — you use it without knowing the internal sorting algorithm.

----------------------------------------------------------------------------
| Aspect         | Encapsulation           | Abstraction                   |
| -------------- | ----------------------- | ----------------------------- |
| Level          | Implementation level    | Design level                  |
| Focus          | How it works internally | What it does                  |
| Achieved using | Access modifiers        | Interfaces / abstract classes |
| Problem solved | Data hiding & safety    | Complexity & design clarity   |
----------------------------------------------------------------------------



======================================== *** Polymorphism *** ========================================================


> Polymorphism means ‘one interface, many forms’. It allows the same method to perform different behaviors based on the 
  object. In Java/C++, polymorphism is of two types: 

  1. compile-time polymorphism (static binding / compile time polymorphism):  achieved through method overloading 
  2. run-time polymorphism (dynamic binding / runtime polymorphism / dynamic dispatch): achieved through method overriding. 
  
  > It improves flexibility, makes code extensible, and supports dynamic behavior — for example, calling overridden methods 
    through parent class references at runtime.


> Dynamic Dispatch: 
  In Java, runtime polymorphism is achieved through dynamic dispatch (also called dynamic or late binding), where the method 
  call is resolved at runtime based on the actual object type rather than the reference type.



======================================== *** Upcasting *** ===============================================================


> For reference: https://www.geeksforgeeks.org/java/upcasting-in-java-with-examples/


> Upcasting is the typecasting of a child object to a parent object. Upcasting can be done implicitly. Upcasting gives us 
  the flexibility to access the parent class members but it is not possible to access all the child class members using 
  this feature. Instead of all the members, we can access some specified members of the child class. For instance, we can 
  access the overridden methods.


> Parent p = new Child();  // upcasting
  p.show();                // runtime polymorphism

  > So: upcasting enables runtime polymorphism but they are not the same thing


> Upcasting is when a child object is referred to by a parent reference. It happens at compile time. Runtime polymorphism 
  occurs when overridden methods are resolved at runtime based on the actual object type. Upcasting enables runtime 
  polymorphism, but upcasting itself is not polymorphism.


> 

======================================== *** super keyword *** =========================================================


> The super keyword in Java is used to refer to the immediate parent class. It is mainly used for three purposes:
  - To access the parent class variables.
  - To call the parent class methods.
  - To call the parent class constructor

> Cannot be used in static context, as static variables and all belongs to a class not to a object. 

> If super() is not used in the child class constructor then default constructor of base class will be called. 
  But if base class have parameterized constructor then super must be used in the child class otherwise it will give 
  compile time error. 

---------------------------------------------------------------------------------------------------------------------------
| Scenario                                             | Java                           | C++                             |
| ---------------------------------------------------- | ------------------------------ | ------------------------------- |
| Base has default constructor                         | `super()` auto inserted, so OK | base default auto-called, so OK |
| Base has no default constructor (only parameterized) | `super(args)` **MANDATORY**    | `: Base(args)` **MANDATORY**    |
---------------------------------------------------------------------------------------------------------------------------



====================================== *** new Keyword *** =========================================================


> Dynamically allocates memory at runtime and returns reference to it. 


===================================== *** this Keyword *** ========================================================


> It refers to the current object.


======================================= *** final Keyword *** ======================================================


> when final Keyword is used, the value of variable become constant i.e. it will not change further. 
  But it holds true only for primitive data types. 

  > If a object is made final then its reference cannot change but values can change. 
    Example: 

    final Student s1 = new Student();
    s1.name = "Amitesh";
    s1.name = "Mohit"; 
    Student s2 = new Student();

    s1 = s2;  Error — cannot change the reference

>> final applies to the reference, not to the object it refers to.

> We cannot override a method if it is final. 

> final can also be used to prevent inheritance in case we do not want to extend the class. 

> final variables must be initialized. 

> If there is final Keyword used before a variable make sure it is written in capital.(as per naming convention) 
  Example: final int PI = 3.14;



==================================== *** finalize method *** ========================================================


> finalize method is called when the object goes out of scope. Since we cannot manually destroy a object we can 
  make finalize method do certain stuffs if needed. 



==================================== *** static Keyword *** ========================================================


> static is a keyword used to define class-level members that belong to the class itself, not to individual objects.

> Memory allocated once, shared by all objects.

> Why static Exists (Interview Angle)
    Saves memory
    Represents common/shared data
    Allows access without creating objects

> By convention static should be accessed using class, but we can access it using reference object but it is not 
  preferred. 

> static block: 

    static {
        System.out.println("Hello from static block");
    }

    > static block is executed only once when the class is loaded for the very first time. 


> Top level class cannot be static. Only inner classes can be static. 
  A top-level class cannot be static because static is used to associate a member with an enclosing class, and a top-level 
  class has no enclosing class. Inner classes can be static or non-static because they belong to another class.


> What static Actually Means ? 
    In Java, static = belongs to the class, not to an object.
        So for static to make sense:
        There must be another class to attach to
        i.e., an enclosing (outer) class


> static variables, methods, classes and stuffs are resolved during compile time. 



============================================ *** Annotations *** =======================================================


> @Override is also one type of annotation. 

